 
//
//  HomeViewController.swift
//  Clicks!
//
//  Created by Leonel Menezes on 24/05/2018.
//  Copyright (c) 2018 Leonel Menezes. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol HomeDisplayLogic: class
{
    func displayOpenChallenges(viewModel: Home.GetOpenChallenges.ViewModel)
}

class HomeViewController: UIViewController, HomeDisplayLogic
{
    
    // MARK: - Variables and constants
    
    var interactor: HomeBusinessLogic?
    var router: (NSObjectProtocol & HomeRoutingLogic & HomeDataPassing)?
    
    ///last scroll offset value
    private var lastOffset : CGFloat = 0.0
    ///scale proportion per point moved in the scroll
    private var homeImageScaleFactor : CGSize = CGSize(width: 0.0, height: 0.0)
    ///scale proportion per point moved in the scroll
    private var profileImageScaleFactor : CGSize = CGSize(width: 0.0, height: 0.0)
    ///scale proportion per point moved in the scroll
    private var configScaleFactor : CGSize = CGSize(width: 0.0, height: 0.0)
    ///move proportion per point moved in the scroll
    private var moveFactor : CGFloat = 0.0
    ///Transformations max distance
    var maxDistanceTransformations : CGFloat = 0.0
    ///Current profile image scale
    private var profileImageScale : CGSize = CGSize(width: 1.0, height: 1.0)
    ///Current home home scale
    private var homeImageScale : CGSize = CGSize(width: 1.0, height: 1.0)

    
    // MARK: - Outlets
    
    //Control Views
    @IBOutlet weak var leftControl: UIControl!
    @IBOutlet weak var middleControl: UIControl!
    @IBOutlet weak var rightControl: UIControl!
    
    //CollectionView
    @IBOutlet weak var containerCollectionView: UICollectionView!
    
    //Images
    @IBOutlet weak var configImage: UIImageView!
    @IBOutlet weak var profileImage: UIImageView!
    @IBOutlet weak var homeImage: UIImageView!
    
    
    // MARK: - Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: - Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = HomeInteractor()
        let presenter = HomePresenter()
        let router = HomeRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: - Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: - View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        fetchOpenChallenges()
        setupImages()
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        self.maxDistanceTransformations = self.profileImage.center.x - homeImage.center.x
        setFactors()
    }
    
    // MARK: Do something
    
    func fetchOpenChallenges() {
        let request = Home.GetOpenChallenges.Request(apiSecret: "", numberOfChallenges: 8)
        interactor?.fetchOpenChallenges(request: request)
    }
    
    func displayOpenChallenges(viewModel: Home.GetOpenChallenges.ViewModel) {
        
    }
    
    ///Sets the initial values for the move and scale factors
    func setFactors() {
        self.moveFactor = (maxDistanceTransformations)/view.frame.width
        self.homeImageScaleFactor = getItemScaleRate(distance: view.frame.width, from: homeImage.frame.size, to: CGSize(width: homeImage.frame.width * 0.75, height: homeImage.frame.height * 0.75))
        self.profileImageScaleFactor = getItemScaleRate(distance: view.frame.width, from: profileImage.frame.size, to: CGSize(width: profileImage.frame.width * 1.066, height: profileImage.frame.height * 1.066))
    }
    
    ///Configures the initial position of images
    func setupImages() {
        
        //Home Image
        
        self.homeImage.translatesAutoresizingMaskIntoConstraints = false
        self.homeImage.centerXAnchor.constraint(equalTo: self.middleControl.centerXAnchor).isActive = true
        self.homeImage.widthAnchor.constraint(equalToConstant: view.frame.width * 0.094).isActive = true
        self.homeImage.heightAnchor.constraint(equalToConstant: view.frame.height * 0.06).isActive = true
        self.homeImage.tintColor = AppColors.clearblack.color
        
        //Profile Image
        self.profileImage.translatesAutoresizingMaskIntoConstraints = false
        self.profileImage.trailingAnchor.constraint(equalTo: self.rightControl.trailingAnchor).isActive = true
        self.profileImage.widthAnchor.constraint(equalToConstant: view.frame.width * 0.07).isActive = true
        self.profileImage.heightAnchor.constraint(equalToConstant: view.frame.height * 0.045).isActive = true
        self.profileImage.tintColor = AppColors.gray.color
        
        //Config Image
        self.configImage.translatesAutoresizingMaskIntoConstraints = false
        self.configImage.leadingAnchor.constraint(equalTo: self.profileImage.trailingAnchor, constant: view.frame.width * 0.33368).isActive = true
    }
    
    @IBAction func leftButtonAction(_ sender: Any) {
    }
    
    
    @IBAction func middleAction(_ sender: Any) {
    }
    
    
    @IBAction func rightAction(_ sender: Any) {
    }
    
}

extension HomeViewController: UICollectionViewDelegate, UICollectionViewDataSource,UICollectionViewDelegateFlowLayout {
    
    // MARK: - Collectionview configuration
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return 2
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "AppPage", for: indexPath)
        if(indexPath.item % 2 == 0){
            cell.backgroundColor = .green
        }
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return 0
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return CGSize(width: containerCollectionView.frame.width, height: containerCollectionView.frame.height)
    }
    
    
    // MARK: - CollectionView ScrollView
    
    
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        //If last offset was smaller than the current one, move items to the right, else move to left.
        let differenceOffsetX = scrollView.contentOffset.x - lastOffset
        updateImagesCenterX(xDistance: -(differenceOffsetX * moveFactor))
        updateImagesScale(xDistance: differenceOffsetX)
        lastOffset = scrollView.contentOffset.x
    }
    
    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
        let pageIndex = scrollView.contentOffset.x/view.frame.width
        if(pageIndex == 0){
            UIView.animate(withDuration: 0.3) {
                self.homeImage.tintColor = AppColors.clearblack.color
                self.profileImage.tintColor = AppColors.gray.color
            }
            
        }else {
            UIView.animate(withDuration: 0.3) {
                self.homeImage.tintColor = AppColors.gray.color
                self.profileImage.tintColor = AppColors.clearblack.color
            }
        }
    }

    
    // MARK: - Scroll Animations
    
    /**
     Updates the images scale as the scrolling happens based on each image scaleFactor
     - Parameters:
        - xDistance: The scroll offset variation
     - Attention: In this case we're using the scrolling distance to scale the items.
     */
    func updateImagesScale(xDistance: CGFloat) {
        self.profileImageScale.width += (profileImageScaleFactor.width * xDistance)
        self.profileImageScale.height += (profileImageScaleFactor.height * xDistance)
        self.homeImageScale.width += (homeImageScaleFactor.width * xDistance)
        self.homeImageScale.height += (homeImageScaleFactor.height * xDistance)
        self.profileImage.transform = CGAffineTransform(scaleX: self.profileImageScale.width, y: self.profileImageScale.height)
        self.homeImage.transform = CGAffineTransform(scaleX: self.homeImageScale.width, y: self.homeImageScale.height)
    }
    
    
    /**
     Changes the images center x with a value to be incremented or decremented.
     - Parameters:
        - xDistance: The distance value to be applied to the images center.
     */
    func updateImagesCenterX(xDistance: CGFloat){
        self.configImage.center.x += xDistance
        self.profileImage.center.x += xDistance
        self.homeImage.center.x += xDistance
    }
    
    /**
     Gets the scale rate of the item based on it's final size and the distance in which it should vary.
     - Parameters:
        - distance: The amount of distance left until the item destination.
        - initialSize: The item initial size
        - finalSize: The item final size at the end of the movement
     - Attention: In this case we should use the screen width, because we're moving the entire screen to resize the items.
     */
    func getItemScaleRate(distance: CGFloat, from initialSize: CGSize, to finalSize: CGSize) -> CGSize{
        
        //First we get the width and height difference from the initial state to the final
        let widthDifference = finalSize.width - initialSize.width
        let heightDifference = finalSize.height - initialSize.height

        //Then we store the percentage of growth of the frame from the beginning
        let widthGrowthPercentage = widthDifference/initialSize.width
        let heightGrowthPercentage = heightDifference/initialSize.height
        
        /*
         If the frame grew n% we just need to update the scale based on how much it should grow by each point moved.
         */
        let growthScalePercentagePerPoint = CGSize(width: widthGrowthPercentage/distance, height: heightGrowthPercentage/distance)

        return growthScalePercentagePerPoint
    }
}
